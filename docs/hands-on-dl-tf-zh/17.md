# 池化层应用

在本节中，我们将研究用于最大池化的 TensorFlow 函数，然后我们将讨论从池化层过渡到完全连接层的过程。 最后，我们将目视观察池输出以验证其减小的大小。

让我们从上一节中停下来的示例开始。 在开始本练习之前，请确保您已执行所有操作直到英镑池层。

回想一下，我们通过 3x3 卷积和校正的线性激活来放置 10x10 图像。 现在，让我们在卷积层之后添加一个最大 2x2 的池化层。

```py
p1 = tf.nn.max_pool(h1, ksize=[1, 2, 2, 1],
          strides=[1, 2, 2, 1], padding='VALID')
```

关键是`tf.nn.max_pool`。 第一个参数只是我们先前的卷积层`h1`的输出。 接下来，我们有一个奇怪的`ksize`。 这实际上只是定义了池的窗口大小。 在这种情况下，为 2x2。 第一个`1`指的是一次或批量多少个数据点。 通常，我们将其保留为`1`。 最后的`1`指的是一次包含在合并中的通道数。 请注意，这里有两个通道，因为卷积产生了两个输出滤波器。 但是我们只有`1`在这个位置； 这是一次最多只有一个特征的唯一故障。 步幅的工作方式与卷积层相同。 此处的区别在于我们使用 2x2（即合并窗口的大小），因为我们不希望有任何重叠。 `1`之前和之后的值与卷积层中的值完全相同。

因此，我们的输出将是每个尺寸的一半，这里是 5x5。 最后，我们将`padding`设置为`VALID`。 这意味着，如果一个窗口超出了图像的边缘（实际上是卷积输出），我们将把它扔掉而不使用它。 如果我们的池化层进入另一个卷积层，则可以在以下代码行中添加它：

```py
# We automatically determine the size
p1_size = np.product([s.value for s in p1.get_shape()[1:]])
```

但是，如果您已经完成了卷积层的工作，并且想要像上一节中的模型那样馈入经典的完全连接层，该怎么办？ 这很容易做到； 我们只需要将具有许多输出通道的 2D 矩阵的输出展平到长的一维向量即可。

该行是自动计算展平池输出长度的一种方法。 它所做的就是乘以所有尺寸的大小。 因此，具有两个通道的 5x5 矩阵将产生`5x5x2`，即`50`输出。 下一行`tf.reshape`使用此值实际展平数组：

```py
p1f = tf.reshape(p1, [-1, p1_size ])
```

前面的代码行中的`-1`用于一次处理许多输入图像的潜在批量。 它告诉 TensorFlow 选择第一个维度，以便参数的总数保持不变。 让我们看一下池化层的输出，以便可以看到一个具体示例：

```py
P = p1.eval(feed_dict = {x: image})
```

首先，我们必须根据给定输入图像来实际评估池输出。

由于池化层取决于卷积层，因此 TensorFlow 会自动将图像首先放置在其中。 我们可以以与卷积输出完全相同的方式查看结果。

![Pooling layer application](img/00057.jpg)

仅查看前面的第一个过滤器输出，您会注意到它是 5x5。

还要注意，存在的值全部在卷积输出的某些单元中。 由于我们在池化层上的唯一激活是最大值，因此在每个 2x2 窗口中会丢弃三个值，并且一个值会前进到下一层。